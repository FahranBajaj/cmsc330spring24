# Exam 2 Review Session

## PL Concepts (20 mins)

#### CFGs
* More expressive than regular expressions
* Non-terminal - can be a few different things (usually written as a capital letter)
* Terminal - a specific string a non-terminal could represent
* You can convert a regex to a CFG but not the other way around
* Examples of rules supported by CFGs but not regexes:
  * Palindromes
  * Relative numbering like a^nb^(2n)
* Modeled using parse trees
  * Left hand and right hand derivations can lead to different trees
* Ambiguous grammar - 2 valid left hand or right hand derivations
* Fixing ambiguous grammars:
  * Make sure the same non-terminal doesn't appear twice like S -> S + S
  * Try adding separate non-terminals

#### Lexing, Parsing, and Interpreters
* Lexing - separating an expression into a list of tokens
  * Fails if a certain word/character is invalid
* Parsing - using this list of tokens to create an AST
  * The parser we are using in class is LL(1) - lookahead by 1 token
  * Type of Recursive Descent Parser
  * Only succeeds on grammatically correct expressions
* Evaluating - finding the value of an expression using the tree generated by the parser
  * Fails if an expression is meaningless in a language (ex: 1 + true)

#### Operational Semantics
* Gives meaning to a language and proves correctness of a program
* 3 kinds of semantics to describe a language
  * Denotational: describes meanings through mathematical constructs/definitions
  * Axiomatic: describes meanings through examples
  * *Operational: describe meanings through how something works*
* Explains how an expression evaluates to a certain value
* Variables stored in the environment

#### Property-Based Testing
* Testing properties that work for all inputs
  * Ex: after a list is reversed, its length and elements are still the same
* Might not always detect bugs

#### Type Checking / Type Inference / Static Analysis
* Seeing if a type system is correct
  * Ex: 1 + 2 is correct but not 1 + true
* Similar to operational semantics except you put the type of a variable in the environment instead of the value

## CFGs
https://colossal-legend-f72.notion.site/CMSC330-EXAM2-CFG-OPSEM-REVIEW-5d745f6773a7463f96e8d097829a4335
## Lexing, Parsing, and Interpreters
- Basic definitons: see PL concepts section above
- Let's walk through an example! [Quiz 3 solutions](https://piazza.com/class/lrf5qvp042i1y2/post/1429)

## Operational Semantics
https://colossal-legend-f72.notion.site/CMSC330-EXAM2-CFG-OPSEM-REVIEW-5d745f6773a7463f96e8d097829a4335
## Property Based Testing

- An approach to testing software by defining general properties and randomly generating test cases to test these properties
- Pioneered by QuickCheck library in Haskell
- The main PBT library for OCaml is also QuickCheck (qcheck when importing)
- How do we write properties?
    - The classic example:
        - If I reverse a list, then reverse it back again, I should have the original list
    - BST examples
        - If i have a valid binary search tree, it should stay a valid binary search tree after inserting a node
        - If I delete a node from a BST, find(deleted node) should evaluate to false and vice versa for insertion
- QuickCheck in OCaml
    - QCheck tests are described by
        - A **generator** that generates random input for our tests
            - what are possible inputs if we want to test the reverse property for lists?
        - A **property →** bool valued function
 ```
let rec rev l = 
  match l with 
   [] -> []
   | h::t -> rev t @ [h]

(* a property that holds for the list reverse *)
let prop_reverse l = rev (rev l) = l

(* #require "qcheck" *)
open QCheck

(* A QCheck test *)
let test =
   Test.make      (* make a test *)
   ~count:1000    (* number of random tests. Change this to a larger number if you want to test more *)
   ~name:”reverse_test”  (* name of the test *)
   (list small_int) (* an arbitrary. Here is generates a list of random ints *)
  (fun x-> prop_reverse x) (* calls the property *)

(* run the QCheck Test *)
QCheck_runner.run_tests ~verbose:true [test];; 
```
- What other properties can we write for reversing lists?
    - what happens to the length of a list if we reverse it?
- QCheck lib → <https://github.com/c-cube/qcheck>

## Type Checking / Type Inference / Static Analysis 

